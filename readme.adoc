# Readme

. Generate Spring Boot project using Spring Initializr.
. Declare project as parent project by changing `packaging` in `pom.xml` to `pom` (instead of `jar`).
. Add a Eureka service registry. 
+
A service registry is a database that stores the instances and locations of services. Service instances register themselves with the registry. Clients/routers that need access to a service then query the registry to find an available instance.footnote:[https://microservices.io/patterns/service-registry.html] This way, we need not hard code the IP addresses of different services and can use services with dynamically assigned IP addresses (e.g. cloud platforms for autoscaling)footnote:[http://javaonfly.blogspot.com/2017/07/microservicespring-cloud-eureka-server.html]. Eureka also provides mid-tier load balancing.
+
.. Create new Maven module project `registration` with `spring-boot-starter-parent` as the parent.
.. Add `registration` as a module to the parent pom.
.. Add https://www.baeldung.com/spring-cloud-netflix-eureka[relevant dependencies] and Spring Boot Maven Plugin to registration's `pom.xml`.
.. Add `ServiceRegistrationServer` and `registration-server.yml` as per https://spring.io/blog/2015/07/14/microservices-with-spring[tutorial].
.. Compile with maven and check that it runs at `http://localhost:1111`.
. Add a microservice, `books-service`.
.. Create Maven module project and update parent POM.
.. Add https://spring.io/guides/gs/service-registration-and-discovery/[relevant dependencies].
.. Add `BooksServer.java` and config file `books-server.yml`. In `books-server.yml`, configure to use IP address instead of hostname. (Eureka's generated hostnames use underscores, which Java does not allow.)
+
[source,xml]
----
instance:
  preferIpAddress: true
----
+
.. Run `registry`, then `books-service`. Check that `books-service` is listed under Applications in `http://localhost:1111`, with details listed in `http://localhost:1111/eureka/apps/books-service`.
. Add more microservices as necessary. See below for communication between microservices.
. Add an API Gateway using Spring Cloud Gateway.
+
An API Gateway serves as a single entry point for client calls by routing requests to the appropriate microservices. Using an API Gateway reduces coupling between clients and microservices, decreases number of (client-server) round trips required, and simplifies handling of cross-cutting concerns like authorization. Read https://microservices.io/patterns/apigateway.html[these] https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern[articles] to find out more.
+
We use Spring Cloud Gateway instead of Zuul for this project so that we can support the reactive stack footnote:[https://stackoverflow.com/a/47094859].
+
.. Create a service (`pom.xml`, `Application.java` with Eureka, config file).
.. Add routing info in Java or ym. See https://github.com/spencergibb/monolith-to-microservices[sample project].
. Add Docker for easier deployment.

## Communication between microservices

### Using `RestTemplate` with Ribbon

Microservices can communicate in various ways. The most basic way is through Spring's `RestTemplate` annotated with `@LoadBalanced`, so that the `RestTemplate` uses a `RibbonLoadBalancerClient` for interactions. This way, logical hosts (e.g. `BOOKS-SERVICE`) are automatically resolved to the actual hosts. footnote:[https://stackoverflow.com/a/43022727] See https://spring.io/blog/2015/07/14/microservices-with-spring[this tutorial] for an example.

### Using Feign

Another method is using Feign, which abstracts away the REST API details. Given a microservice, we create an interface for each microservice it calls annotated with `@FeignClient` with the name (`spring.application.name`) of the microservice to be called. Declare the endpoints to be used within the interface. Finally, add `@EnableFeignClients` to the main class. Instead of calling the microservices via `RestTemplate`, we can now call the methods listed in the interface (which are implemented by Feign). See https://piotrminkowski.wordpress.com/2018/04/26/quick-guide-to-microservices-with-spring-boot-2-0-eureka-and-spring-cloud/[this article] for an example.



## Deploying 

### Running manually

Run mvn spring-boot:run for each of the projects

. registry
. book-service
. web-service
. gateway

### Using Dockerfile

. run mysql container
+
[source]
----
docker run -d \
    --name demo-mysql \
    -e MYSQL_ROOT_PASSWORD=p4SSW0rd \
    -e MYSQL_DATABASE=demo \
    -e MYSQL_USER=dbuser \
    -e MYSQL_PASSWORD=dbp4ss \
    mysql:latest
----
+
. create docker image
+
[source]
----
mvn clean package dockerfile:build
----
+
. run docker image linked to mysql container
+
[source]
----
docker run -it \
    --name book-service-dbuild \
    --link demo-mysql:mysql-docker-container \
    -p 2222:2222 \
    springdemo/book-service
----

### Using Docker-compose

. For each module, run `mvn clean package dockerfile:build`.
. In main project, run `docker-compose up`.